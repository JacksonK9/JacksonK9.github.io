<!DOCTYPE html>
<html
  dir="ltr"
  lang="en"
  data-theme=""
  class="html"
><head>
  <title>
    
      
        기타 그래프 이론 |

      
      Jackson Kim


    
  </title>

  
  <meta charset="utf-8" /><meta name="generator" content="Hugo 0.95.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="author" content="Jackson Kim" />
  <meta
    name="description"
    content="
      Wanna be Good SLAMer


    "
  />
  
  
    
    
    <link
      rel="stylesheet"
      href="/scss/main.min.b2e0cb07595e3519ab1193bb421914e06c0e26b0cc561fef23b3c6131d4d2ffa.css"
      integrity="sha256-suDLB1leNRmrEZO7QhkU4GwOJrDMVh/vI7PGEx1NL/o="
      crossorigin="anonymous"
      type="text/css"
    />

  

  
  <link
    rel="stylesheet"
    href="/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css"
    integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU="
    crossorigin="anonymous"
    type="text/css"
  />
  
    <link rel="stylesheet" href="https://JacksonK9.github.io/css/table.css"/>
  
  
  <link
    rel="stylesheet"
    href="/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css"
    integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link
    rel="stylesheet"
    href="/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css"
    integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link
    rel="stylesheet"
    href="/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css"
    integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link rel="shortcut icon" href="/favicons/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png" />

  <link rel="canonical" href="https://JacksonK9.github.io/algorithm/graph_theory/" />

  
  
  
  
  <script
    type="text/javascript"
    src="/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js"
    integrity="sha256-&#43;RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI="
    crossorigin="anonymous"
  ></script>

  
    
    
    <script
      type="text/javascript"
      src="/js/anatole-theme-switcher.min.560a26330d27ff44a44e83b53cd07a95d4230a65930d31c5c76a8d481e5b35bf.js"
      integrity="sha256-VgomMw0n/0SkToO1PNB6ldQjCmWTDTHFx2qNSB5bNb8="
      crossorigin="anonymous"
    ></script>

  

  


  
  <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://JacksonK9.github.io/images/site-feature-image.png"/>

<meta name="twitter:title" content="기타 그래프 이론"/>
<meta name="twitter:description" content="참고 원본 - 기타 그래프 이론 Table of Contents  서로소 집합  서로소 집합의 특징 서로소 집합의 구현 서로소 집합의 활용   최소 신장 트리  최소 신장 트리의 특징 크루스칼 알고리즘   위상 정렬 리뷰  서로소 집합  서로소 집합 $\rightarrow$ 공통 원소가 없는 두 집합을 의미 ({1, 2}, {3, 4} 두 집합은 공통 원소가 없으므로, 서로소 집합)  서로소 집합 자료 구조란?"/>



  
  <meta property="og:title" content="기타 그래프 이론" />
<meta property="og:description" content="참고 원본 - 기타 그래프 이론 Table of Contents  서로소 집합  서로소 집합의 특징 서로소 집합의 구현 서로소 집합의 활용   최소 신장 트리  최소 신장 트리의 특징 크루스칼 알고리즘   위상 정렬 리뷰  서로소 집합  서로소 집합 $\rightarrow$ 공통 원소가 없는 두 집합을 의미 ({1, 2}, {3, 4} 두 집합은 공통 원소가 없으므로, 서로소 집합)  서로소 집합 자료 구조란?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://JacksonK9.github.io/algorithm/graph_theory/" /><meta property="og:image" content="https://JacksonK9.github.io/images/site-feature-image.png"/><meta property="article:section" content="algorithm" />
<meta property="article:published_time" content="2022-05-25T22:28:43+09:00" />
<meta property="article:modified_time" content="2022-05-25T22:28:43+09:00" /><meta property="og:site_name" content="TIL the END" />




  
  
  
  
  <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "articleSection": "algorithm",
        "name": "기타 그래프 이론",
        "headline": "기타 그래프 이론",
        "alternativeHeadline": "",
        "description": "
      
        참고 원본 - 기타 그래프 이론 Table of Contents  서로소 집합  서로소 집합의 특징 서로소 집합의 구현 서로소 집합의 활용   최소 신장 트리  최소 신장 트리의 특징 크루스칼 알고리즘   위상 정렬 리뷰  서로소 집합  서로소 집합 $\\rightarrow$ 공통 원소가 없는 두 집합을 의미 ({1, 2}, {3, 4} 두 집합은 공통 원소가 없으므로, 서로소 집합)  서로소 집합 자료 구조란?


      


    ",
        "inLanguage": "en-us",
        "isFamilyFriendly": "true",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/JacksonK9.github.io\/algorithm\/graph_theory\/"
        },
        "author" : {
            "@type": "Person",
            "name": "Jackson Kim"
        },
        "creator" : {
            "@type": "Person",
            "name": "Jackson Kim"
        },
        "accountablePerson" : {
            "@type": "Person",
            "name": "Jackson Kim"
        },
        "copyrightHolder" : {
            "@type": "Person",
            "name": "Jackson Kim"
        },
        "copyrightYear" : "2022",
        "dateCreated": "2022-05-25T22:28:43.00Z",
        "datePublished": "2022-05-25T22:28:43.00Z",
        "dateModified": "2022-05-25T22:28:43.00Z",
        "publisher":{
            "@type":"Organization",
            "name": "Jackson Kim",
            "url": "https://JacksonK9.github.io/",
            "logo": {
                "@type": "ImageObject",
                "url": "https:\/\/JacksonK9.github.io\/favicons\/favicon-32x32.png",
                "width":"32",
                "height":"32"
            }
        },
        "image": 
      [
        
        "https://JacksonK9.github.io/images/site-feature-image.png"


      
      ]

    ,
        "url" : "https:\/\/JacksonK9.github.io\/algorithm\/graph_theory\/",
        "wordCount" : "981",
        "genre" : [ ],
        "keywords" : [ ]
    }
  </script>



</head>
<body
    
      class="body theme--light"

    
  >
    <div class="wrapper">
      <aside
        
          class="wrapper__sidebar"

        
      ><div
  class="sidebar
    animated fadeInDown

  "
>
  <div class="sidebar__content">
    <div class="sidebar__introduction">
      <img
        class="sidebar__introduction-profileimage"
        src="/images/K9.jpg"
        alt="profile picture"
      />
      
        <div class="sidebar__introduction-title">
          <a href="/">TIL the END</a>
        </div>

      
      <div class="sidebar__introduction-description">
        <p>Wanna be Good SLAMer</p>
      </div>
    </div>
    <ul class="sidebar__list">
      
        <li class="sidebar__list-item">
          <a
            href="https://github.com/JacksonK9/"
            target="_blank"
            rel="noopener"
            aria-label="GitHub"
            title="GitHub"
          >
            <i class="fab fa-github fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
        <li class="sidebar__list-item">
          <a
            href="mailto:k9632441@gmail.com"
            target="_blank"
            rel="noopener"
            aria-label="e-mail"
            title="e-mail"
          >
            <i class="fas fa-envelope fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
    </ul>
  </div><footer class="footer footer__sidebar">
  <ul class="footer__list">
    <li class="footer__item">
      &copy;
      
        Jackson Kim
        2022


      
    </li>
    
  </ul>
</footer>
  
  <script
    type="text/javascript"
    src="/js/medium-zoom.min.a3fd0638ada4e3cec287e49a604b4a828cfef33a669afe60b96575761fff5cf3.js"
    integrity="sha256-o/0GOK2k487Ch&#43;SaYEtKgoz&#43;8zpmmv5guWV1dh//XPM="
    crossorigin="anonymous"
  ></script><script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN" crossorigin="anonymous"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
    </script></div>
</aside>
      <main
        
          class="wrapper__main"

        
      >
        <header class="header"><div
  class="
    animated fadeInDown

  "
>
  <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
    <span aria-hidden="true" class="navbar-burger__line"></span>
    <span aria-hidden="true" class="navbar-burger__line"></span>
    <span aria-hidden="true" class="navbar-burger__line"></span>
  </a>
  <nav class="nav">
    <ul class="nav__list" id="navMenu">
      
      
        
        
          <li class="nav__list-item">
            <a
              
              href="/"
              
              title=""
              >Home</a
            >
          </li>

        


      
        
        

          <li class="nav__list-item">
            <div class="optionswitch">
              <input class="optionswitch__picker" type="checkbox" id="1" hidden />

              
              
                


              
                


              
                


              
                


              
                


              


              <label class="optionswitch__label" for="1"
                >Posts <i class="fa fa-angle-down" aria-hidden="true"></i
              ></label>

              <div class="optionswitch__triangle"></div>
              <ul class="optionswitch__list">
                
                  <li class="optionswitch__list-item">
                    <a
                      href="/algorithm/"
                      
                      title=""
                      >Algorithm</a
                    >
                  </li>

                
                  <li class="optionswitch__list-item">
                    <a
                      href="/programming/"
                      
                      title=""
                      >Programming</a
                    >
                  </li>

                
                  <li class="optionswitch__list-item">
                    <a
                      href="/cv/"
                      
                      title=""
                      >Computer Vision</a
                    >
                  </li>

                
                  <li class="optionswitch__list-item">
                    <a
                      href="/robotics/"
                      
                      title=""
                      >Robotics</a
                    >
                  </li>

                
                  <li class="optionswitch__list-item">
                    <a
                      href="/etc/"
                      
                      title=""
                      >ETC</a
                    >
                  </li>

                
              </ul>
            </div>
          </li>

        


      
        
        
          <li class="nav__list-item">
            <a
              
              href="/plans/"
              
              title=""
              >Plans</a
            >
          </li>

        


      
    </ul>
    <ul class="nav__list nav__list--end">
      
      
        <li class="nav__list-item">
          <div class="themeswitch">
            <a title="Switch Theme">
              <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a>
          </div>
        </li>

      
    </ul>
  </nav>
</div>
</header>
  <div
    class="post 
      animated fadeInDown

    "
  >
    
    <div class="post__content">
      <h1>기타 그래프 이론</h1>
      
        <ul class="post__meta">
          <li class="post__meta-item">
            <em class="fas fa-calendar-day post__meta-icon"></em>
            <span class="post__meta-text"
              >
                
                  2022/05/25


                


              
            </span>
          </li>
          <li class="post__meta-item">
            <em class="fas fa-stopwatch post__meta-icon"></em>
            <span class="post__meta-text">5-minute read</span>
          </li>
        </ul>

      <h4 id="참고-원본---기타-그래프-이론httpswwwyoutubecomwatchvaohhnftiefilistplrx0vpvlemdaghtr5mxqxgphjwqsz0dgcindex8"><a href="https://www.youtube.com/watch?v=aOhhNFTIeFI&amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC&amp;index=8">참고 원본 - 기타 그래프 이론</a></h4>
<h3 id="table-of-contents">Table of Contents</h3>
<ul>
<li>서로소 집합
<ul>
<li><a href="#%EC%84%9C%EB%A1%9C%EC%86%8C-%EC%A7%91%ED%95%A9">서로소 집합의 특징</a></li>
<li><a href="#%EC%84%9C%EB%A1%9C%EC%86%8C-%EC%A7%91%ED%95%A9-%EA%B5%AC%ED%98%84">서로소 집합의 구현</a></li>
<li><a href="#%EC%84%9C%EB%A1%9C%EC%86%8C-%EC%A7%91%ED%95%A9-%ED%99%9C%EC%9A%A9">서로소 집합의 활용</a></li>
</ul>
</li>
<li>최소 신장 트리
<ul>
<li><a href="#%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC">최소 신장 트리의 특징</a></li>
<li><a href="#%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">크루스칼 알고리즘</a></li>
</ul>
</li>
<li><a href="#%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC">위상 정렬</a></li>
<li><a href="#%EB%A6%AC%EB%B7%B0">리뷰</a></li>
</ul>
<h3 id="서로소-집합">서로소 집합</h3>
<ul>
<li>서로소 집합 $\rightarrow$ 공통 원소가 없는 두 집합을 의미 ({1, 2}, {3, 4} 두 집합은 공통 원소가 없으므로, 서로소 집합)
<img src="/images/graph_theory/%EC%84%9C%EB%A1%9C%EC%86%8C.png" alt="서로소 집합"></li>
<li>서로소 집합 자료 구조란?
<ul>
<li>서로소 판별을 위해 사용할 수 있는 자료 구조</li>
<li>서로소 부분 집합들로 나뉘어진 원소들의 데이터 처리를 위한 자료 구조</li>
</ul>
</li>
<li>지원하는 연산
<ul>
<li>합집합 연산 (Union) $\rightarrow$ 서로소 집합을 합치는 연산</li>
<li>찾기 연산 (Find) $\rightarrow$ 특정한 원소가 속한 집합이 어디인지 알려주는 연산</li>
<li>Union 과 Find 연산을 지원하는 자료 구조로, Union-Find 자료 구조라고도 합니다.</li>
</ul>
</li>
<li>서로소 집합 자료 구조에서 Root Node가 같은 원소는 같은 집합을 의미</li>
</ul>
<hr>
<h3 id="서로소-집합-구현">서로소 집합 구현</h3>
<ul>
<li>
<p>Tree 자료 구조 활용</p>
</li>
<li>
<p>주의 : Tree에서 Root Node는 최상단에 위치한 Node를 의미하며, 부모 Node는 각 Node 바로 위에 있는 Node를 의미한다.</p>
</li>
<li>
<p>ex) 1 ~ 6을 가지는 서로소 집합 자료구조</p>
<ul>
<li>최초에는 1의 부모는 1, 2의 부모는 2와 같은 형식으로 자기 자신을 부모로 놓고 시작
<img src="/images/graph_theory/%EC%B5%9C%EC%B4%88%EC%83%81%ED%83%9C.png" alt="서로소집합_최초상태"></li>
<li>합치기 연산
<ul>
<li>Union(A, B) $\rightarrow$ A의 Root인 A&rsquo;과 B의 Root인 B&rsquo;을 찾아서, 내부적인 규칙(작은 값 or 큰 값이 높은 우선 순위)에 맞춰서 A&rsquo;의 부모를 B&rsquo;의 부모로 설정</li>
<li>ex) Union(0, 3) $\rightarrow$ 0의 Root인 0, 3의 Root인 3을 찾고, 0이 숫자가 작으므로, 3의 부모가 0이 되도록 변경</li>
</ul>
</li>
<li>이와 같은 합치기 연산을 통해, 합치기를 진행</li>
<li>Union(1, 4), Union(2, 3) 연산 진행 후의 결과
<img src="/images/graph_theory/%ED%95%A9%EC%B9%98%EA%B8%B0%ED%9B%84.png" alt="서로소집합_합치기후"></li>
</ul>
</li>
<li>
<p>단점 $\rightarrow$ 각 Node의 Root를 찾을 때, 한 번에 찾을 수 없고, 재귀를 통해, 자기의 부모가 자기 자신일 때까지 호출을 통해 찾을 수 있음</p>
</li>
<li>
<p>ex) 5 $\rightarrow$ 4 $\rightarrow$ 3 $\rightarrow$ 2 $\rightarrow$ 1 의 형태로 된 구조라면, 5의 Root를 찾을 때까지 5번의 호출이 필요</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">findRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="c1">## parent는 각 Node의 부모가 누구인지 적혀 있는 List, x는 부모를 찾을 Node</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">findRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span>
</span></span></code></pre></div><ul>
<li>경로 압축 알고리즘 $\rightarrow$ 위와 같은 비효율을 해결하기 위해, Find 함수를 재귀적으로 호출하면서, 모든 값의 부모를 Root로 Update</li>
<li>이런 방식을 사용하면, 최초 Root를 찾을 때를 제외하고는 시간 복잡도가 개선되는 장점이 있음!</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">findRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="c1">## parent는 각 Node의 부모가 누구인지 적혀 있는 List, x는 부모를 찾을 Node</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">findRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
</span></span></code></pre></div><hr>
<h3 id="서로소-집합-활용">서로소 집합 활용</h3>
<ul>
<li>무방향 그래프 내에서의 사이클 판별에 사용 (방향 그래프의 사이클 여부는 DFS를 통해 판별)
<ol>
<li>각 간선을 하나씩 확인하여, 연결된 두 Node의 Root Node를 확인</li>
<li>두 Node의 Root Node가 다르다면, 두 Node에 대해, 합집합 연산 수행</li>
<li>두 Node의 Root Node가 동일하다면, 사이클이 발생했다고 판단</li>
<li>그래프에 포함된 모든 간선에 대해 1 ~ 3의 과정을 반복</li>
</ol>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">unionNode</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span> <span class="c1">## parent는 각 Node의 부모가 누구인지 적혀 있는 List, a, b는 합칠 Node</span>
</span></span><span class="line"><span class="cl">    <span class="n">root_a</span> <span class="o">=</span> <span class="n">findRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">root_b</span> <span class="o">=</span> <span class="n">findRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">root_a</span> <span class="o">&lt;</span> <span class="n">root_b</span><span class="p">:</span> <span class="c1"># 우선 순위에 따라 결정</span>
</span></span><span class="line"><span class="cl">        <span class="n">parent</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_a</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">parent</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_b</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">findCycle</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span> <span class="c1">## parent는 각 Node의 부모가 누구인지 적혀 있는 List, edges는 각 그래프의 Node 연결에 대한 정보가 있는 List</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">node_a</span><span class="p">,</span> <span class="n">node_b</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">root_a</span> <span class="o">=</span> <span class="n">findRoot</span><span class="p">(</span><span class="n">node_a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">root_b</span> <span class="o">=</span> <span class="n">findRoot</span><span class="p">(</span><span class="n">node_b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">root_a</span> <span class="o">==</span> <span class="n">root_b</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">union</span><span class="p">(</span><span class="n">node_a</span><span class="p">,</span> <span class="n">node_b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">False</span>
</span></span></code></pre></div><hr>
<h3 id="최소-신장-트리">최소 신장 트리</h3>
<ul>
<li>신장 트리 $\rightarrow$ 그래프에서 모든 Node를 포함하면서, 사이클이 없는 <code>부분 그래프</code>를 의미
<ul>
<li>Tree의 조건 $\rightarrow$ 모든 Node가 포함되어 연결되면서, 사이클이 존재하지 않음</li>
</ul>
</li>
<li>최소 신장 트리 $\rightarrow$ 최소한의 비용으로 구성되는 신장 트리 (간선의 비용이 다를 경우)</li>
<li>ex) 최소 비용으로 모든 도로를 연결하는 다리 만들기</li>
<li>최소 신장 트리의 간선 개수 $\rightarrow$ 전체 Node 수 - 1
<img src="/images/graph_theory/%EC%8B%A0%EC%9E%A5%ED%8A%B8%EB%A6%AC.png" alt="신장트리"></li>
</ul>
<h3 id="크루스칼-알고리즘">크루스칼 알고리즘</h3>
<ul>
<li>대표적인 최소 신장 트리 알고리즘 (그리디 알고리즘으로 분류)</li>
<li>크루스칼 알고리즘 구현
<ol>
<li>간선의 모든 비용을 오름차순으로 정렬</li>
<li>간선을 하나씩 확인하며, 사이클이 발생하는 지 확인</li>
<li>사이클이 발생하지 않는다면, 해당 간선을 최소 신장 트리에 포함</li>
<li>사이클이 발생한다면, 해당 간선을 포함하지 않고 다음으로</li>
<li>모든 간선에 대해 2 ~ 4의 과정을 반복</li>
</ol>
</li>
<li>간선의 개수가 N개일 때, 시간 복잡도 $\rightarrow$ $O(NlogN)$</li>
<li>이는 가장 오래 걸리는 부분이, 전체 간선의 비용을 오름차순으로 정렬하는 것이기 때문
<img src="/images/graph_theory/%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.png" alt="크루스 칼알고리즘"></li>
</ul>
<h3 id="위상-정렬">위상 정렬</h3>
<ul>
<li>DAG (Directed Acyclic Graph) : 사이클이 없는 방향 그래프</li>
<li>DAG의 모든 Node를 방향을 거스르지 않도록 순서대로 나열하는 것을 의미</li>
<li>ex) 선수과목을 고려한 학습 순서 결정 문제
<img src="/images/graph_theory/%EC%84%A0%EC%88%98%EA%B3%BC%EB%AA%A9.png" alt="선수과목"></li>
<li>위를 위상 정렬하면 <code>자료구조</code> $\rightarrow$ <code>알고리즘</code> $\rightarrow$ <code>고급 알고리즘</code>으로 정렬</li>
<li>방향 그래프의 진입차수 &amp; 진출차수
<ul>
<li>진입 차수 : 특정 Node로 들어오는 간선의 수</li>
<li>진출 차수 : 특정 Node에서 나가는 간선의 수
<img src="/images/graph_theory/%EC%A7%84%EC%9E%85%EC%B6%9C%EC%B0%A8%EC%88%98.png" alt="진입출차수"></li>
</ul>
</li>
<li>사이클이 있는 경우 사이클 내부에서는 진입 차수가 0이 될 수 없으므로, 위상 정렬 알고리즘 적용이 불가능</li>
<li>위상 정렬 알고리즘 구현
<ul>
<li>Queue를 이용한 구현
<ol>
<li>진입 차수가 0인 Node를 모두 Queue에 넣기</li>
<li>Queue에서 하나를 꺼내고, 해당 Node에서 나가는 간선 모두 지우기</li>
<li>새롭게 진입 차수가 0이 된 Node들을 모두 Queue에 넣기</li>
<li>Queue에 Node가 하나도 없을 때까지 2 ~ 3의 내용을 반복</li>
</ol>
<ul>
<li>Queue에 넣을 때 or Queue에서 꺼낼 때 순서를 적으면 위상 정렬 수행 순서</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">topology_sort</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">indegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 진입 차수 확인</span>
</span></span><span class="line"><span class="cl">            <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">now</span><span class="p">]:</span> <span class="c1"># 현재 그래프와 연결된 값들 1씩 제거</span>
</span></span><span class="line"><span class="cl">            <span class="n">indegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">indegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
</span></span></code></pre></div></li>
<li>Stack을 이용한 구현
<ol>
<li>진입 차수가 0인 Node를 모두 Stack에 넣기</li>
<li>Stack에서 하나를 꺼내고, 해당 Node에서 나가는 간선 모두 지우기</li>
<li>새롭게 진입 차수가 0이 된 Node들을 모두 Stack에 넣기</li>
<li>모든 Node 방문이 끝나면 종료</li>
</ol>
<ul>
<li>Stack에 넣을 때의 순서를 적으면 위상 정렬 수행 순서</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">topology_sort</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">indegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 진입 차수 확인</span>
</span></span><span class="line"><span class="cl">            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">s</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">now</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">now</span><span class="p">]:</span> <span class="c1"># 현재 그래프와 연결된 값들 1씩 제거</span>
</span></span><span class="line"><span class="cl">            <span class="n">indegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">indegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>위상 정렬의 답은 하나가 아님! (한 번에 여러 개의 진입 차수가 0이 될 경우, 무엇을 먼저 넣느냐에 따라 결과가 달라짐)
<img src="/images/graph_theory/%EC%9C%84%EC%83%81%EC%A0%95%EB%A0%AC%EC%98%88%EC%8B%9C.png" alt="위상정렬예시"></li>
<li>모든 원소를 방문하기 전에 Queue가 모두 비었다면, 사이클이 존재하는 것으로 판별</li>
<li>모든 Node 및 간선을 제거해야하므로 시간 복잡도는 O(N + E)</li>
</ul>
<h3 id="리뷰">리뷰</h3>
<ul>
<li>여러가지 Graph의 활용 예시에 대해 알아보았다.</li>
<li>이름만 들어본 크루스칼 알고리즘 같은 내용을 보니 신기했다</li>
<li>내용이 특별한 것보다, 이름만 들어보고 내용을 몰랐던 것을 알아서 신기했다.</li>
<li>기존에 알고리즘 문제에서 이와 같은 예시를 본 것 같은데, 이제 풀어봐야겠다.</li>
</ul>
</div>
    <div class="post__footer">
      

      
    </div>

    <div id="comment">
          <h2>comments</h2>
          <script
  src="https://utteranc.es/client.js"
  repo="JacksonK9/blog_comments"
  issue-term="pathname"
  theme="preferred-color-scheme"
  
  crossorigin="anonymous"
  async
></script>

        </div>
  </div>


      </main>
    </div><footer class="footer footer__base">
  <ul class="footer__list">
    <li class="footer__item">
      &copy;
      
        Jackson Kim
        2022


      
    </li>
    
  </ul>
</footer>
  
  <script
    type="text/javascript"
    src="/js/medium-zoom.min.a3fd0638ada4e3cec287e49a604b4a828cfef33a669afe60b96575761fff5cf3.js"
    integrity="sha256-o/0GOK2k487Ch&#43;SaYEtKgoz&#43;8zpmmv5guWV1dh//XPM="
    crossorigin="anonymous"
  ></script><script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN" crossorigin="anonymous"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
    </script></body>
</html>
